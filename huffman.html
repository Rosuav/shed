<!DOCTYPE HTML>
<html>
<head>
<title>Huffman text analysis</title>
<link rel="stylesheet" href="https://fperucic.github.io/treant-js/Treant.css">
<style>
#treedisplay {
	height: 900px;
	width: 1900px;
	margin: 5px;
}
.node {
	width: 5em; height: 5em;
	font-size: 18px;
	text-align: center;
	padding: 3px;
	border: 1px solid black;
}
p.node-title, p.node-name, p.node-desc, p.node-contact {
	margin: 0.25em 0;
}
.Treant .collapse-switch {width: 100%; height: 100%; background: #0f01;}
.Treant .node.collapsed .collapse-switch {background: #0ff1;}
</style>
</head>
<body>
<!--
TODO: Huffman tree visualization as text analysis. Could be an interesting showcase project for stream, talking about
data compression and data analysis. Needs a good way to visualize the tree, the rest is easy.
- Do the whole thing in a single file in shed
- Accept "file upload" and do the calculations in JS
- Letters only, alphanumeric, or all characters
- Monocase or as-is
-->
<main>
<p>
	<input type=file id=analyzeme>
	<label><input type=radio name=filter id=alpha checked> Simple alpha</label>
	<label><input type=radio name=filter id=text> Textual characters</label>
	<label><input type=radio name=filter id=all> All characters</label>
</p>
<div id=treedisplay></div>
</main>
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
<script src="https://fperucic.github.io/treant-js/vendor/raphael.js"></script>
<script src="https://fperucic.github.io/treant-js/Treant.js"></script>
<script>
function huffman_tree(text, alphabet, monocase) {
	const counts = { };
	for (let i = 0; i < text.length; ++i) {
		let ltr = text[i];
		if (monocase) ltr = ltr.toLowerCase();
		if (alphabet && !alphabet.test(ltr)) continue;
		counts[ltr] = (counts[ltr]|0) + 1;
	}
	const nodes = Object.keys(counts).map(key => [counts[key], key])
	while (nodes.length > 1) {
		//1. Find the two lowest-frequency entries in the counts mapping
		nodes.sort((a, b) => b[0] - a[0]);
		const left = nodes.pop();
		const right = nodes.pop();
		//2. Merge them by combining their keys and assigning "0" and "1" to each
		//3. Put the merged pair back into the tree as a subtree.
		nodes.push([left[0] + right[0], [left, right]]);
	}
	return nodes[0];
}
function treantify(tree, path) {
	if (typeof(tree[1]) == "string") {
		//Leaf node
		return {text: {desc: ""+tree[0], contact: path, name: tree[1]}};
	}
	else {
		//Subtree
		return {text: {desc: ""+tree[0], contact: "â€¦"}, children: [
			treantify(tree[1][0], path + "0"),
			treantify(tree[1][1], path + "1"),
		]};
	}
}
document.getElementById("analyzeme").addEventListener("change", function(e) {
	console.log("Got file");
	console.log(this.files);
	let alphabet = null, monocase = false;
	if (document.getElementById("alpha").checked) {alphabet = /[a-z]/; monocase = true;}
	else if (document.getElementById("text").checked) alphabet = /\p{Alphabetic}/u;
	if (this.files.length) this.files[0].text().then(text => {
		document.getElementById("treedisplay").innerHTML = "";
		new Treant({
			chart: {
				container: "#treedisplay",
				node: {collapsable: true},
			},
			nodeStructure: treantify(huffman_tree(text, alphabet, monocase), ""),
		});
	})
}, false);
</script>
</body>
</html>
