#!/usr/bin/env python3
'''
TODO: Progressive text search
- Give it a file name
- Type letters/digits/apostrophe, or space, or punctuation, or Enter/Up/Down
- If letter/digit, add to search term
- If space, add separator
- If punctuation, add to filter? maybe? Hyphen requires hyphen, double quote allows any quote (incl backtick b/c people), comma allows semicolon
- Enter/Down = next, Up = prev. Reset to start on search change? Or keep position (not index)?
- Search for a sequence of words. They may be separated by any amount of non-newline whitespace, punctuation, etc.
- Two newlines is a hard separator - no hit crosses that boundary
- Match based on Unicode casefold, but show the original
- Search term <<i'm sure i can't be mabel>> finds Alice falling down rabbit hole despite line break
- Search term <<"a dog's not mad>> finds the conversation with the Cat - even though it's opened with a single quote
'''
import curses
import sys

if len(sys.argv) < 2:
	sys.exit(1, "USAGE: %s filename" % sys.argv[0])
with open(sys.argv[1]) as f:
	textfile = f.readlines()

tracefile = open("/tmp/txtfind.log", "w")
def trace(*a, **kw): print(*a, **kw, file=tracefile, flush=True)

handlers = { }
def keyhandler(*keys):
	def wrapper(func):
		for key in keys: handlers[key] = func
		return func
	return wrapper

def keyrange(start, end):
	# Or should this record the range and do inequality checks??
	return keyhandler(*(chr(k) for k in range(ord(start), ord(end) + 1)))

search = [""]

@keyhandler("KEY_UP", "KEY_DOWN")
def scroll(key):
	# TODO: Next/previous search result
	trace("Scrolling!", key)

@keyrange("A", "Z")
@keyrange("a", "z")
@keyrange("0", "9")
@keyhandler("'")
def search_char(key):
	search[-1] += key

@keyhandler("KEY_BACKSPACE")
def search_unchar(key):
	if search[-1]: search[-1] = search[-1][:-1]
	elif search: search.pop()

@keyhandler(" ")
def search_newterm(key):
	search.append("")

def main(stdscr):
	curses.set_escdelay(25) # What's the smallest timeout that won't result in spurious exits?
	stdscr.clear()
	curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
	found_text = curses.color_pair(1) | curses.A_BOLD
	while True:
		stdscr.addstr(1, 0, "Hello, ")
		stdscr.addstr("world", found_text)
		stdscr.addstr("!")
		for i, term in enumerate(search):
			stdscr.addstr(i + 3, 0, term)
			stdscr.clrtoeol()
		stdscr.clrtobot()
		stdscr.addstr(curses.LINES - 1, 0, "> ", curses.A_BOLD)
		stdscr.refresh()
		key = stdscr.getkey()
		if key == "\x1b": break
		func = handlers.get(key)
		if func: func(key)
		elif len(key) == 1:
			# Single-character. Most likely, add to search term.
			trace("One-character: %r" % key)
		else:
			trace("Unknown key %r" % key)

curses.wrapper(main)
